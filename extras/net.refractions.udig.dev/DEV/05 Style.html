<html>
    <head>
        <META http-equiv="Content-Type" content="text/html; charset=UTF-8">
        <link rel="stylesheet" href="../book.css" type="text/css" />
        <title>UDIG Developer Guide : 05 Style</title>
    </head>
    <body BGCOLOR="#FFFFFF">
       <!-- UDIG Developer Guide : 05 Style -->
       <h1>05 Style</h1>

       <p>uDig can provide maps symbolized by implementing styles.<br/>
A style describes how to paint points, lines, polygons and raster data sets by providing a set of painting rules.</p>
<ul>
	<li><a href="#05Style-StyleFramework">Style Framework</a></li>
	<li><a href="#05Style-SLDContentandStyleLayerDescriptorHandling">SLDContent and Style Layer Descriptor Handling</a></li>
</ul>


<h1><a name="05Style-StyleFramework"></a>Style Framework</h1>

<p>The style api has three major players:</p>
<ul>
	<li><b>StyleBlackboard</b>: a persisted blackboard of all the user supplied rendering settings for a layer</li>
	<li><b>StyleContent</b>: this is used to hold any object you wish on the style blackboard. Methods exist to load / save your object, and create a default object.
	<ul>
		<li>For the <b>org.geotools.styling.Style</b> object (representing an SLD file) the value is managed by the class SLDContent.</li>
	</ul>
	</li>
	<li><b>StyleConfigurator</b>: This the the user interface responsible for editing a style on the style blackboard.</li>
</ul>


<p>The udig will use the entire style blackboard, as well as all nown renderereds when choosing how to draw what is on the screen. RenderMetricsFactory and RenderingMetrics are both used to inspect the style blackboard and the renderer that is able to understand the most is chosen to draw what is on the screen.</p>

<h2><a name="05Style-StyleObjectandStyleBlackboard"></a>Style Object and StyleBlackboard</h2>

<p>Style objects are stored a StyleBlackboard. Configurators use the blackboard to collaborate. Objects are stored on the blackboard by id. When a configurator queries the blackboard for an object and it does not exist, a default object should be created and placed on the blackboard. The following is an example:</p>

<p>Since different renders can use completely different style objects, the coupling between the render and the style needs to kept low. In order to achieve this, we decided to create the notion of a style blackboard which is associated with a layer. This way the render and configurator can collaborate without talking to each other.</p>

<p>The Renderer and the StyleConfigurator look for particular style objects on the blackboard in order to do their part. The style content is responsible for creating, and persiting the style object.</p>

<p>Each Layer has a StyleBlackboard. Configurators should not write to this blackboard directly. Each configurator is supplied with a copy of the actual layer blackboard.<br/>
Each time a style object is changed, it must be replaced onto the blackboard for persistance reasons.</p>

<p>The StyleConfigurator should store no state. All state should be stored in the style objects on the style blackboard. When a ui widget changes state, the style object should be written to immediately to reflect the change.</p>

<p>When the configurator becomes active, the ui widgets should be initialized from the values of style objects on the blackboard. This should be performed every time refresh() is called. </p>

<p>Whenever style objects are read from the blackboard, </p>
<div class="code panel" style="border-width: 1px;"><div class="codeContent panelContent">
<pre class="code-java">void apply() {
      StyleBlackboard styleBlackboard = getStyleBlackboard();
      Point style = styleBlackboard.lookup(<span class="code-quote">"point.style"</span>);      
      <span class="code-keyword">if</span> (style == <span class="code-keyword">null</span>) {
          style = <span class="code-keyword">new</span> Point();    
          styleBlackboard.put(<span class="code-quote">"point.style"</span>, style);
      }
      
      style.setX(...) <span class="code-comment">//set to some value from ui
</span>      style.setY(...) <span class="code-comment">//set to some value from ui
</span>  }
  
  void init() {
      StyleBlackboard styleBlackboard = getStyleBlackboard();
      Point style = styleBlackboard.lookup(<span class="code-quote">"point.style"</span>);
      <span class="code-keyword">if</span> (style != <span class="code-keyword">null</span>) {
          <span class="code-comment">//set some ui widget to value of style.getX();
</span>          <span class="code-comment">//set some ui widget to value of style.getY();
</span>      }
  }</pre>
</div></div>

<h1><a name="05Style-SLDContentandStyleLayerDescriptorHandling"></a>SLDContent and Style Layer Descriptor Handling</h1>

<p>So now that you have looked at the general framework; lets look at the one that matters - the representation of the OGC SLD Document as managed by SLDContent.</p>

<h4><a name="05Style-DefaultStyle"></a>Default Style</h4>

<p>SLDContent will ask your GeoResource for a default style; you have several ways of supplying a default:</p>
<ul>
	<li>For a Shapefile you can include an *.sld file; ShpGeoResourceImpl already knows how to check for this file and will provide it to SLDCOntent &#8211; using resolve( Style, null )</li>
	<li>If you are making your own GeoResource you can make sure canResolve( Style.class) returns true</li>
	<li>If you are adding a default style to an existing GeoResource (like ArcSDE) you will need to use an IResolveAdapaterFactory to teach the existing class about your default style.</li>
</ul>


<h2><a name="05Style-SLDsutilityclass"></a>SLDs utility class</h2>

<p>Since a Style is composed of a complex set of objects, a StyleBuilder object is provided for you to conveniently build simple styles without the need to build all of the style elements by hand. For example, you can create a PolygonSymbolizer and then create a Style out of it with a single method call: the builder will generate a default FeatureTypeStyle and the Rule for you. </p>

<h3><a name="05Style-FeatureTypeStyle"></a>FeatureTypeStyle</h3>

<p>A FeatureTypeStyle declares a part of a style that is specifically geared toward a FeatureType, that is, features will be rendered according to this FeatureTypeStyle only if their FeatureType is the same as the FeatureType declared in the FeatureTypeStyle or a descendent. A FeatureTypeStyle contains one or more rules; </p>

<h3><a name="05Style-Rule"></a>Rule</h3>

<p>A Rule contains filters that will decide whether features will be displayed or not, specifically:<br/>
a minimum and maximum map scale, if set and the current scale is outside the specified range, the rule won't apply and thus its symbolizers won't be used; <br/>
a Filter that is applied to the features, only the features matching the filter will be painted according to the Rule symbolizers; <br/>
as an alternative, the rule can have an "else filter". This special kind of filter catches all of the features that still haven't been symbolized by previous rules with a regular filter. </p>

<h3><a name="05Style-Symbolizers"></a>Symbolizers</h3>

<p>A Symbolizer describes how to represent a feature on the screen based on the feature contents (geometry and attributes). Each rule can have one or more Symbolizer attached to it. </p>
<ul>
	<li>Text Symbolizer</li>
	<li>Line Symbolizer</li>
	<li>Polygon Symbolizer</li>
	<li>Point Symbolizer</li>
	<li>Raster Symbolizer</li>
</ul>


<div class="panel" style="border-width: 1px;"><div class="panelHeader" style="border-bottom-width: 1px;"><b>Links</b></div><div class="panelContent">
<ul>
	<li><a href="http://www.opengis.org/docs/02-070.pdf">Styled Layer Descriptor Reference Document </a></li>
</ul>
</div></div>

<small>
  (c) Copyright (c) 2004-2008 Refractions Research Inc. and others.<br>
  <a href="http://udig.refractions.net/confluence/pages/viewpage.action?pageId=5029">[wiki]</a>
</small>
    </body>
</html>