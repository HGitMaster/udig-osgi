<html>
    <head>
        <META http-equiv="Content-Type" content="text/html; charset=UTF-8">
        <link rel="stylesheet" href="../book.css" type="text/css" />
        <title>UDIG Developer Guide : 2 uDig extension points list</title>
    </head>
    <body BGCOLOR="#FFFFFF">
       <!-- UDIG Developer Guide : 2 uDig extension points list -->
       <h1>2 uDig extension points list</h1>

       <h2><a name="2uDigextensionpointslist-uDigExtensionPointsList"></a>uDig Extension Points List</h2>

<table class='confluenceTable'><tbody>
<tr>
<th class='confluenceTh'> Extension Point </th>
<th class='confluenceTh'> Description </th>
</tr>
<tr>
<td class='confluenceTd'>ConnectionHandler</td>
<td class='confluenceTd'>Defines a handler for exception that occur when attempting to import data into the system.</td>
</tr>
<tr>
<td class='confluenceTd'>dataWizards</td>
<td class='confluenceTd'>Defines all the data import wizards used by udig.</td>
</tr>
<tr>
<td class='confluenceTd'>decorator</td>
<td class='confluenceTd'>A Decorator is a adds meaning to a map or page. The Decorator interface that a decorator extension must extend consists of a draw() method and a setToolkit() method. The toolkit passed in provides context for the decorator. For example, a scalebar requires a viewport model and the ability to calculate the extent of a map; the toolkit provides access to that data. The toolkit the decorator receives is a read only toolkit. A decorator is not permitted to change UDIG model information. It can only display information.</td>
</tr>
<tr>
<td class='confluenceTd'>dropAction</td>
<td class='confluenceTd'>Attach an action to the drop event in a drag n drop transaction.</td>
</tr>
<tr>
<td class='confluenceTd'>editorAreaDropActions</td>
</tr>
<tr>
<td class='confluenceTd'>editorInputs</td>
</tr>
<tr>
<td class='confluenceTd'>featureEditor</td>
<td class='confluenceTd'>Allow Extenders to add custom features editors to udig. Context menus that open when the ActivePage has a feature as part of the selection will have an "Edit Feature" item and an "Edit With" submenu. These new feature editors will begin the "Edit With" menu and if chosen will be also accessible when the "Edit Feature" item is selected(until the time that a different editor is chosen in the "Edit With" menu"</td>
</tr>
<tr>
<td class='confluenceTd'>featureType</td>
<td class='confluenceTd'>List featureType operation extensions. FeatureType Operations as choices within the "Operation" menu (context, popup, and tools menu), and are typically used to process reports and summaries, perform modificaitons on the content in place, or transform content.</td>
</tr>
<tr>
<td class='confluenceTd'>infoDisplay</td>
</tr>
<tr>
<td class='confluenceTd'>itemProviderAdapterFactories</td>
<td class='confluenceTd'>Used to allow other plug-ins to contribute their own item provider adapter factories generated by EMF.Edit for use in views.</td>
</tr>
<tr>
<td class='confluenceTd'>layerOp</td>
<td class='confluenceTd'>Performs an operation on one or more layers in a map.  Layer operations are listed under the layer menu and in context menus in the layer view when a layer is right clicked.  In order provide a scalable solution the layer operation extension point requires a extension to declare a filter that will allow the menu managers to determine whether the layer operation is interested in the layer.  If it is then the operation will be added to the menu.  Otherwise the operation will be left out of the menu.</td>
</tr>
<tr>
<td class='confluenceTd'>mapgraphic</td>
</tr>
<tr>
<td class='confluenceTd'>ServiceExtension</td>
</tr>
<tr>
<td class='confluenceTd'>operation</td>
</tr>
<tr>
<td class='confluenceTd'>operationExtension</td>
<td class='confluenceTd'>Any new type of extension that cannot be satisfied by the normal operations extension point can extend this extension point.  Extenders must have an operation element that matches the operations element in operation.exsd.</td>
</tr>
<tr>
<td class='confluenceTd'>persister</td>
<td class='confluenceTd'>Persist objects of a specified type. Persistence is achievied by using a memento to capture internal object state.</td>
</tr>
<tr>
<td class='confluenceTd'>projectElementFactories</td>
<td class='confluenceTd'>projectElementFactories</td>
</tr>
<tr>
<td class='confluenceTd'>provider</td>
<td class='confluenceTd'>Provide object instances. Providers must declare the type of object they provide, and an optional key which identifies the object type.</td>
</tr>
<tr>
<td class='confluenceTd'>renderer</td>
<td class='confluenceTd'>A Renderer interprets spatial data and represents the data in a visual manner. In UDIG there are different types of renderers that can render different types of data. For example, a feature renderer can render features data. A WMS renderer can communicate with and render images from a web map server. The API requires that a Renderer extension must create a RenderMetrics class, which can provide metrics about how fast a renderer can provide its service, a RenderMetricsFactory class, which can determine if a data source can be rendered by the renderer and can create RenderMetrics that provide metrics with regard to a particular data source and, last, a renderer extension must provide an implementation of the Renderer Interface. Normally by extending the abstract superclass which handles threading and event notification for the renderer. For the sake of simplicity and security a toolkit object is provided that the renderer can use. This provides the user with a buffered image that the renderer can write on and provide a single interface for obtaining all information that the renderer may need.</td>
</tr>
<tr>
<td class='confluenceTd'>renderExecutor</td>
<td class='confluenceTd'>Declares render executors to use for rendering particular types of renderers.  Renderers are not required to implement a executor.  The default ones will work in most cases.</td>
</tr>
<tr>
<td class='confluenceTd'>selectionOp</td>
<td class='confluenceTd'>An definition for an operation on a map's or layer's current selection. A layer's selection is represented by the filter returned by getFilter. The selection is the features selected by the filter. A map's selection is the join of all the layer's selections.</td>
</tr>
<tr>
<td class='confluenceTd'>sldEditorPart</td>
<td class='confluenceTd'>Style Layer Desriptor (SLD) style content.</td>
</tr>
<tr>
<td class='confluenceTd'>style</td>
<td class='confluenceTd'>Configures a style object. Responsibilties include: <br/>
Creating a ui to allow user configuration of a style object. <br/>
Placing style object information onto the style blackboard of a layer. <br/>
Determining if a style configurator can be used to configure the style of a particular layer.</td>
</tr>
<tr>
<td class='confluenceTd'>styleDefinition</td>
<td class='confluenceTd'>Styles are represented as a Memento object which contains style information as a tree of mementos each of which contains strings. Only the renderers that render a layer know the concrete style class. This means that only certain renderers are capable of rendering certain styles. However as far as UDig is concerned a style is a memento. This causes problems with the user interface because udig does not know anything about the style. To overcome this limitation a style must be associated with an editor dialog. The editor must extend the StyleEditor class. A style is used for rendering purposes. Renderers use style objects when rendering Layer data. A style can be any object. Extenders are expected to create the style object itself, as well as an implementation of StyleContent which is uses a factory for the style. Style objects are placed onto a Layer blackboard so they can be accessed by other entities such as Renderers and StyleConfigurators.</td>
</tr>
<tr>
<td class='confluenceTd'>styleConfigurator</td>
</tr>
<tr>
<td class='confluenceTd'>templates</td>
<td class='confluenceTd'>A Template is used to layout elements on a Page that will be use for printing.</td>
</tr>
<tr>
<td class='confluenceTd'>tool</td>
<td class='confluenceTd'>Allows third-party developers to develop new tools for UDIG and is one of the most used points of extension. There are three different type of tools and two ways of grouping tools. The three type of tools are as follows:<br/>
<b>Action Tool</b> - A single fire tool that performs a single action and is not modal, a buttons that sets the viewport so it frames the current selection is an example of an action tool. Action tools must implement the ActionTool interface. <br/>
<b>Modal Tool</b> - A tool that has on and off modes. When a modal tool is "on" it waits for user input and reacts on it. An example of a modal tool is the zoom tool. Modal tools must implement the ModalTool interface and are recommended to implement the AbstractModalTool class. <br/>
<b>Background Tool</b> - A tool that is always active in the background. A typical background tool would be limited to providing user feedback. An example is the cursor position tool that displays the current mouse location in world coordinates. Background tools must implement the Tool interface and are recommended to implement the AbstractTool class. <br/>
To address the need to provide locations for large numbers of tools developers can add tools to views. In addition, a standard tool views is defined and new tools are added to the tool viewer by default. It is recommended that if a large number of tools are being added then a new view should be created to hold the tool set. The setToolkit method is called by UDIG in order to provide a tools with a toolkit object that it can use as a facade for access UDIG, UDIG command factories and send command object to UDIG.</td>
</tr>
</tbody></table>

<small>
  (c) Copyright (c) 2004-2008 Refractions Research Inc. and others.<br>
  <a href="http://udig.refractions.net/confluence/pages/viewpage.action?pageId=5027">[wiki]</a>
</small>
    </body>
</html>